비트마스킹 DP (Bitmask Dynamic Programming)

방문한 노드들이나 집합의 상태를 배열이 아닌 하나의 정수(이진수 비트)로 표현하여, 메모리를 절약하고 비트 연산을 통해 상태 전이를 매우 빠르게 처리하는 기법입니다. 

대표적으로 외판원 순회(TSP) 문제가 있습니다.



의사코드 (Pseudocode - 외판원 순회)

Plaintextfunction TSP(current_node, visited_mask):
    // 모든 노드를 방문한 경우 (비트가 모두 1인 상태)
    if visited_mask == (1 << N) - 1:
        if Graph[current_node][start_node] != 0:
            return Graph[current_node][start_node]
        else:
            return INF
            
    // 이미 계산된 상태라면 메모이제이션 반환
    if dp[current_node][visited_mask] != -1:
        return dp[current_node][visited_mask]
        
    min_cost = INF
    for next_node from 0 to N-1:
        // 방문하지 않은 노드이고, 가는 경로가 존재한다면
        if (visited_mask AND (1 << next_node)) == 0 and Graph[current_node][next_node] != 0:
            next_mask = visited_mask OR (1 << next_node)
            cost = Graph[current_node][next_node] + TSP(next_node, next_mask)
            min_cost = min(min_cost, cost)
            
    dp[current_node][visited_mask] = min_cost
    return min_cost



복잡도:

시간 복잡도: O(N^2 * 2^N) (N: 정점의 개수)

공간 복잡도: $O(N * 2^N)




공학적 설명: 

순열을 사용하여 모든 경로를 탐색하면 O(N!)이 소요되어 N=11만 되어도 시간 초과가 발생합니다. 

하지만 비트마스킹을 적용한 DP는 겹치는 부분 문제(Overlapping Subproblems)를 메모이제이션하여 연산량을 획기적으로 줄여줍니다. 

단, 지수 시간이 소요되므로 N의 최댓값이 보통 16~18 이하로 매우 엄격하게 제한될 때만 사용할 수 있는 기법입니다.



디버깅 체크포인트 (Edge Cases):

비트 연산자 우선순위: 

   1 << N - 1은 의도와 다르게 1 << (N - 1)로 계산될 수 있습니다. 

   반드시 (1 << N) - 1처럼 괄호를 묶어 우선순위 오류를 방지해야 합니다.

불가능한 경로의 반환값 처리: 

   INF 값을 더하다가 자료형의 한계를 넘어 오버플로우가 발생하여 음수가 반환될 수 있습니다. 

   min_cost 비교 시 INF 방어 로직이 필요합니다.

시작점의 일반화: 

   경로가 사이클을 이루는 TSP의 경우 어떤 노드에서 시작하든 최종 비용이 같으므로 시작점을 0번 노드로 고정해도 되지만, 

   사이클로 돌아오지 않는 단순 경로 탐색의 경우 시작점을 임의로 고정하면 오답이 발생합니다.
