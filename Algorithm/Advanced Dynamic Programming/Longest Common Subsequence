최장 공통 부분 수열 (LCS, Longest Common Subsequence)

두 수열이나 문자열이 주어졌을 때, 순서를 유지하면서 공통으로 들어있는 가장 긴 부분 수열을 찾는 알고리즘입니다.



의사코드 (Pseudocode)

Plaintextfunction LCS(string A, string B):
    N = A.length
    M = B.length
    dp[][] = 0으로 초기화 (크기: (N+1) x (M+1))
    
    for i from 1 to N:
        for j from 1 to M:
            if A[i-1] == B[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
                
    return dp[N][M]



복잡도:

시간 복잡도: O(N * M)

공간 복잡도: O(N * M) (필요시 슬라이딩 윈도우로 O(min(N, M)) 최적화 가능)



공학적 설명: 

두 문자열의 길이를 곱한 만큼의 상태 공간을 탐색합니다. 

문자열의 길이가 1,000 이하일 때는 매우 빠르게 동작하지만, 

길이가 100,000을 넘어가면 연산량이 100억 번에 달해 사용할 수 없습니다. 

공간 복잡도 역시 10,000 * 10,000 크기의 int 2차원 배열은 약 400MB를 차지하여 메모리 초과를 유발합니다. 

현재 행의 계산은 바로 이전 행(i-1)의 데이터만 필요로 하므로, 

크기가 2인 1차원 배열 2개를 교차 사용하는 토글링(Toggling) 기법으로 메모리를 극적으로 줄일 수 있습니다.



디버깅 체크포인트 (Edge Cases):

빈 문자열 입력: 

   입력 문자열 중 하나라도 길이가 0인 경우, 

   배열 인덱스 접근 시 Out of Bounds 오류가 발생할 수 있습니다.

모든 문자가 동일하거나 완전히 다름: 

   두 문자열이 완벽히 같거나 단 하나의 공통 문자도 없을 때 점화식이 올바른 기저 조건(Base Case 0)을 반환하는지 확인해야 합니다.

실제 부분 수열 역추적 누락: 

   단순히 길이를 구하는 것이 아니라 실제 부분 수열의 원소들을 출력해야 하는 문제에서, 

   2차원 DP 테이블을 거꾸로 추적(Backtracking)하는 로직의 인덱스가 어긋나는 경우가 흔합니다.
