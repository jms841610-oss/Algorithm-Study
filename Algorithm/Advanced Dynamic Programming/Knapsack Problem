배낭 문제 (0/1 Knapsack Problem)

주어진 배낭의 최대 무게 용량 내에서, 담을 수 있는 물건들의 가치 합을 최대화하는 알고리즘입니다. 

물건을 쪼갤 수 없는(0/1) 상황을 다룹니다.



의사코드 (Pseudocode)

function Knapsack(W_max, weights[], values[], N):
    // 1차원 배열로 공간 복잡도 최적화
    dp[] = 0으로 초기화 (크기: W_max + 1)
    
    for i from 1 to N:
        // 중복 선택을 막기 위해 무게를 뒤에서부터 역순으로 탐색
        for w from W_max down to weights[i]:
            dp[w] = max(dp[w], dp[w - weights[i]] + values[i])
            
    return dp[W_max]



복잡도:

시간 복잡도: O(N \times W) (N: 물건의 수, W: 배낭의 최대 무게)

공간 복잡도: O(W) (1차원 배열 최적화 시)



공학적 설명: 

이 알고리즘은 다항 시간이 아닌 의사 다항 시간(Pseudo-polynomial time) 알고리즘입니다. 

물건의 개수 N이 100개로 작더라도, 최대 무게 W가 10^9 처럼 매우 크다면 시간 초과(TLE)와 메모리 초과(MLE)가 동시에 발생합니다. 

따라서 W의 제약 조건이 100,000 이하일 때만 이 DP 방식을 적용할 수 있으며, 

그 이상일 경우 '중간에서 만나기(Meet in the Middle)' 등의 탐색 기법을 고려해야 합니다.



디버깅 체크포인트 (Edge Cases):

배열 갱신 방향 오류: 

   1차원 배열을 사용할 때 무게를 앞에서부터(1 to W_max) 순회하면, 
   
   하나의 물건이 여러 번 담기는 무한 배낭(Unbounded Knapsack) 문제로 변질됩니다.

가치 합의 오버플로우: 

   물건들의 가치(values) 합이 int의 최댓값(약 21억)을 초과할 수 있는지 확인하고, 

   필요시 long long 배열을 사용해야 합니다.

무게가 0인 물건: 

   가치는 있지만 무게가 0인 물건이 존재할 경우, 

   역순 탐색 시 인덱스 처리와 최적해 갱신이 누락될 수 있으므로 예외 처리가 필요합니다.
