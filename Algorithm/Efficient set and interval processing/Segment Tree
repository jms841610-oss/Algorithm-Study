세그먼트 트리 (Segment Tree)

배열의 특정 구간에 대한 연산(구간 합, 구간 최솟값/최댓값 등)과 특정 요소의 업데이트를 빠르게 수행하는 완전 이진 트리 형태의 자료구조입니다.




의사코드 (Pseudocode)

Plaintexttree[] = 4 * N 크기로 할당

function Build(node, start, end):
    if start == end:
        tree[node] = array[start]
        return tree[node]
    
    mid = (start + end) / 2
    left_val = Build(node*2, start, mid)
    right_val = Build(node*2 + 1, mid + 1, end)
    tree[node] = left_val + right_val  // 구간 합 기준
    return tree[node]

function Query(node, start, end, left, right):
    if left > end or right < start:
        return 0  // 범위를 벗어나면 결과에 영향 없는 값 반환
    if left <= start and end <= right:
        return tree[node]
        
    mid = (start + end) / 2
    return Query(node*2, start, mid, left, right) + 
           Query(node*2 + 1, mid + 1, end, left, right)



복잡도:

시간 복잡도: 생성 O(N), 쿼리 및 업데이트 O(log N)

공간 복잡도: O(N) (실제로는 4N 크기의 배열 필요)



공학적 설명: 

배열의 원소가 연속적으로 변하는 상황에서 단순 배열 탐색으로 구간 합을 구하면 

M번의 쿼리에 대해 $O(M * N)$이 걸려 시간 초과가 발생합니다. 

세그먼트 트리는 데이터를 이진 트리 형태로 분할 저장하여, 

노드 개수 N=100,000 일 때 트리 높이 약 17단계(log_2 N)만 탐색하므로 쿼리당 연산량을 획기적으로 줄입니다.



디버깅 체크포인트 (Edge Cases):

트리 크기 할당 오류: 

   트리 배열 크기를 넉넉하게 4 * N 으로 잡지 않으면 자식 노드 접근(node*2 + 1) 시 메모리 참조 오류(SegFault)가 발생합니다.

오버플로우 (데이터 타입): 

   구간 합의 경우 노드들의 합이 누적되므로 int 범위를 훌쩍 넘을 수 있습니다. 

   트리 배열을 long long으로 선언했는지 확인해야 합니다.

무효 구간의 반환값: 

   최솟값 세그먼트 트리에서 탐색 범위를 벗어났을 때 0을 반환하면 오답이 됩니다. 

   반드시 문제 제약 조건보다 큰 무한대(INF)를 반환해야 합니다.
